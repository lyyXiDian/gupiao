#coding=gbk
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf

#――――――――――――――――――导入数据――――――――――――――――――――――
f = open('/Users/liyangyang/Downloads/fund_data.csv')
df = pd.read_csv(f)
data = np.array(df['price']) #获取最高价序列
data = data[::-1] #反转，是数据按照日期先后顺序排列

#折线图展示data
plt.figure()
plt.plot(data)
plt.show()
normalize_data = (data - np.mean(data))/np.std(data)#标准化
normalize_data = normalize_data[:,np.newaxis] #增加维度

#形成训练集
#设置常量
time_step = 20
rnn_unit = 10 #隐藏层单元
batch_size = 10
input_size = 1
output_size = 1
lr = 0.0006
train_x, train_y = [], []
for i in range(len(normalize_data) - time_step - 1):
    x = normalize_data[i: i+time_step]
    y = normalize_data[i+1: i+time_step+1]
    train_x.append(x.tolist())
    train_y.append(y.tolist())



#――――――――――――――――――定义神经网络变量――――――――――――――――――
X = tf.placeholder(tf.float32, [None, time_step, input_size])
Y = tf.placeholder(tf.float32, [None, time_step, output_size])
weights = {
    'in':tf.Variable(tf.random_normal([input_size, rnn_unit])),
    'out':tf.Variable(tf.random_normal([rnn_unit,1]))
}
biases = {
    'in':tf.Variable(tf.constant(0.1, shape=[rnn_unit, ])),
    'out':tf.Variable(tf.constant(0.1,shape=[1,]))
}


#定义lstm神经网络
def lstm(batch):
    w_in = weights['in']
    b_in = biases['in']
    input = tf.reshape(X, [-1, input_size]) #需要将tensor转成2维进行计算，计算后的结果作为隐藏层的输入
    input_rnn = tf.matmul(input, w_in) + b_in
    input_rnn = tf.reshape(input_rnn, [-1, time_step, rnn_unit]) #将tensor转成3维，作为lstm cell的输入
    cell = tf.nn.rnn_cell.BasicLSTMCell(rnn_unit, reuse = tf.AUTO_REUSE)
    init_state = cell.zero_state(batch, dtype=tf.float32)
    output_rnn, final_states = tf.nn.dynamic_rnn(cell, input_rnn, initial_state=init_state, dtype=tf.float32)
    output = tf.reshape(output_rnn, [-1, rnn_unit]) #作为输出层的输入
    w_out = weights['out']
    b_out = biases['out']
    pred = tf.matmul(output, w_out) + b_out
    return pred, final_states

#训练模型
def train_lstm(train_begin, train_end):
    global batch_size
    pred,_ = lstm(batch_size)
    #损失函数
    loss = tf.reduce_mean(tf.square(tf.reshape(pred,[-1]) - tf.reshape(Y, [-1])))
    train_op = tf.train.AdamOptimizer(lr).minimize(loss)
    saver = tf.train.Saver(tf.global_variables())
    with tf.Session() as sess:
        sess.run(tf.global_variables_initializer())
        #重复训练10000次
        for i in range(10):
            step = 0
            start = 0
            end = start + batch_size
            while(end < len(train_x)):
                _,loss_ = sess.run([train_op, loss], feed_dict={X:train_x[start:end], Y:train_y[start:end]})
                start += batch_size
                end = start + batch_size
                #每10步保存一次参数
                if step%10 == 0:
                    print (i, step, loss_)
                    print ("保存模型：", saver.save(sess, '/Users/liyangyang/PycharmProjects/gupiao/stock.model'))
                step += 1

#预测模型
def prediction(test_begin):
    pred, _ = lstm(1) #预测时只输入【1， time_step. input_size]的测试数据
    saver = tf.train.Saver(tf.global_variables())
    with tf.Session() as sess:
        #参数恢复
        module_file = tf.train.latest_checkpoint('/Users/liyangyang/PycharmProjects/gupiao/')
        saver.restore(sess, module_file)
        #取训练集最后一行为样本测试。shape=[1,time_step,input_size]
        prev_seq = train_x[-1]
        predict = []
        #得到之后预测的5个结果
        for i in range(50):
            next_seq = sess.run(pred, feed_dict={X:[prev_seq]})
            predict.append(next_seq[-1])
            # 每次得到最后一个时间步的预测结果，与之前的数据加在一起，形成新的测试样本
            prev_seq = np.vstack((prev_seq[1:], next_seq[-1]))
        #以折线图表示结果
        plt.figure()
        plt.plot(list(range(len(normalize_data))), normalize_data, color = 'b')
        plt.plot(list(range(len(normalize_data), len(normalize_data) + len(predict))), predict, color = 'r')
        plt.show()

train_begin = 0
train_end = len(normalize_data)*0.8

train_lstm(train_begin=train_begin, train_end=train_end)
prediction(test_begin=train_end)
